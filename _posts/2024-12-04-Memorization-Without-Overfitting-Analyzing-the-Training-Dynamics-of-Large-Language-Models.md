---
title: 大模型训练动态论文笔记
description: notes for ”Memorization without overfitting“
tags:
  - ai-explanation
  - llm-unlearning
category: AI
date: 2024-12-04
---
尽管大型语言模型被广泛采用，但人们对其潜在的训练和记忆动态还不是很了解。我们实证研究了因果语言模型和掩蔽语言模型中跨模型大小和整个训练过程的精确记忆。我们测量了数据集大小、学习率和模型大小对记忆的影响，发现**较大的语言模型在所有设置中记忆训练数据的速度都更快**。令人惊讶的是，我们发现**较大的模型可以在过度拟合之前记住更大一部分数据，并且在整个训练过程中遗忘的更少**。我们还分析了不同词性的记忆动态，发现**模型首先记忆名词和数字**；我们假设并提供实证证明了**名词和数字是记忆单个训练示例的唯一标识符**。
## 本文的背景
模型记住其训练数据的速率和程度提供了有关它如何可能泛化到新测试实例的证据。经典框架（偏差-方差均衡）主张在不完全记忆的情况下拟合训练集，但近期深度学习的研究建立的记忆和泛化之间更为共生的关系[^13][^26][^28]。

语言模型近期的大部分性能提升都来自于规模。众所周知，较大的模型会记忆更多的训练数据，这是提高泛化能力的关键因素。然而，令人惊讶的是，在理解规模对语言模型记忆训练动态的影响方面，研究相对较少。现有研究主要侧重于分析事后训练（post-training）的记忆。本文研究语言模型中的记忆和遗忘动态，衡量它们在扩大模型规模时如何变化。

[13]: When is memorization of irrelevant training data necessary for high-accuracy learning?
[26]: Does learning require memorization. A short tale about a long tail.
[28]: What neural networks memorize and why: Discovering the long tail via influence estimation.

## 本文要研究的问题
训练过程中大语言模型记忆随着数据规模，模型规模和学习率等的动态变化。
## 相关工作
无意记忆是语言模型面临的一个已知挑战，这使它们容易受到提取攻击和成员推理攻击。最近的研究表明，记忆并非完全有害，对于某些类型的泛化（例如，在 QA 任务中）至关重要，同时还允许模型编码大量的世界或事实知识。先前的研究广泛分析了训练动态，以了解神经模型如何在训练过程中获取信息 。Saphra 和 Lopez是第一批分析语言建模训练动态的人，他们专注于内部表征在预训练过程中的演变。这启发了一系列研究，分析神经语言模型如何在预训练过程中学习语言结构/世界知识、单个单词和跨语言结构。

也有研究工作研究语言模型中的记忆退化（遗忘）。灾难性遗忘或灾难性干扰研究神经网络在使用新数据进行训练时，如何倾向于忘记来自先前训练任务或训练批次的信息。这为持续学习（或终身学习）带来了关键挑战，其目标是从一次通常非常大的数据流中逐渐学习。已经提出了许多机制来提高对灾难性遗忘的鲁棒性。还有越来越多的研究表明，模型和数据集规模都可以使模型更能抵抗遗忘。机器反学习是一种强制训练模型忘记先前学习过的样本的技术，其主要动机是数据保护和隐私法规。

## 研究方法
使用标签记忆作为指标度量记忆程度，因为它一直为神经网络的基本特性提供理论见解，在经验环境中仍然适用，并且计算成本相对较低。本文将度量标准表述为**自监督场景的标签记忆的模拟**。使用大模型准确预测下一个token的概率作为记忆程度，然后以需要在数据上进行记忆住数据信息的最少的梯度下降更新次数来衡量记忆速度。

给定一组上下文$$C$$，每个包含一个输入上下文$$s$$和一个输出token$$y$$。如果$$arg\max(f(s))==y$$，就认为一个上下文$$c=(s,y)\in C$$被模型记住了。然后将整个上下文集合被记住的比例表示为
$$
M(f)=\frac{\sum_{(s,y)\in C}\mathbb{1}\{arg\max(f(s))=y\}}{\vert C\vert}
$$

给定一个阈值$$\tau$$，使用$$T(N,\tau)$$表示一个$$N$$个参数的大语言模型要满足$$M(f)\geq\tau$$的话需要见每个训练样本的次数。因为大型语言模型一般预训练不会训练多个epoch，每个样本都只会见一次。本文使用$$M_{Update}(f,U)$$作为模型对第$$U$$次梯度下降更新时的训练数据批次的记忆程度（对这个批次的数据的记忆比例）。然后使用$$T_{update}(N,\tau)$$作为满足记忆比例的最小的梯度下降更新次数。

原来的定义方法包括：
+ $$k$$-memorized：字符串通过训练数据中k个token的上下文的提示就可以提取出来
+ $$k$$-eidetic memorized：字符串可以被提取并且包含在最多$$k$$个训练样本中
+ 影响函数：如果在包含样本的数据子集和不包括样本的数据子集上预期模型性能的差异足够大，则认为模型记住了样本。

## 主要结论
**更大的模型记忆更快**

在预训练的过程中检测了$$T(N,\tau)$$的值（所以这个玩意怎么算，每更新一次就统计一次预测对的样本数，然后统计一下比例，满足比例了就记录更新次数？），发现125M大的模型需要将近170次梯度下降更新才能达到记忆比例，而13B模型只需要低于10次更新，说明更大的模型对信息的记忆速度更快。同一规模的模型下，需要的记忆比例越高更新次数越多，但是随着模型变大，不同记忆比例需要的更新次数逐渐会下降到差不多的程度。更大的模型一开始的记忆程度和其他模型没什么区别，但很快就能达到更全的记忆程度。因果语言模型和掩码语言模型都是越大记忆速度越快。

> 为什么？

一般来说记忆与过度拟合有关。本文检查了过拟合发生之前的记忆。在验证集上的语言模型困惑度增加的首个epoch，认为模型出现了过拟合。随着参数数量的增加，过拟合之前的记忆通常会增加，说明过拟合本身无法完全解释随着模型规模增加而出现的记忆动态特性。

即使固定学习率，记忆比例也会很快达到90%，说明记忆速度与学习率无关。随着模型规模增加， 对学习率的敏感度通常会降低。学习率会先下降，然后缓慢上升，但前后变化并不明显。对于超过特定规模的神经语言模型，学习率并不是一个重要的超参数。

**和唯一标识符的关系**

本文在训练集中的每个示例前面添加一个唯一标识符（文档ID），并检查记忆速度是否会提高。为了利用所有这些ID就必须将它们添加到词表中，因此会导致模型大小显著增加，所以M(f) 动态的任何变化都可以归因于通过增加词典大小而添加的额外参数。

为了控制这一点，本文首先检查仅增加字典大小（不使用任何添加的标记）的效果。然后利用这些添加的标记添加到每个训练示例的前面，并观察记忆比例的动态变化。**增加词表大小确实可以提高记忆速度，哪怕这些唯一标识符完全没有使用。当利用这些添加的标记来唯一地标识训练示例时会看到记忆的另一个增益**，尽管在prompt中使用文档ID并不会使记忆动态随时间单调增加。

**和词性长度的关系**

本文追踪了正确预测了词性的位置的数量和对应词性在数据集中出现次数的比值。正确预测的词性并不一定意味着准确记忆，语言模型记忆词性的速度比记忆token的准确值的速度更快。虽然所有词性最终都会被记住，但有些词性记忆得更快。**名词、专有名词和数字的记忆速度明显快于动词和形容词**。*这对隐私有潜在影响，因为敏感信息很可能是名词/专有名词/数字。*

**语言模型的遗忘曲线**

遗忘曲线假说表示当人类不尝试保留记忆时，记忆会随着时间的推移而衰退。本文首先使用遗忘集作为特殊批次，然后选择了模型的一个checkpoint，插入特殊批次进行训练，然后在训练集上恢复标准训练，最后评估特殊批次上的记忆退化情况（模型对特殊批次的记忆比例）。

特殊批次的精确记忆一开始会迅速下降，但随着继续训练，遗忘曲线会呈指数级下降。换句话说，**特殊批次的遗忘曲线似乎最后会接近一个基线**—我们将此趋势称为遗忘基线。可以通过查看整个训练过程中特殊批次的最低记忆值来近似遗忘基线。**基线的数值随着模型规模单调递增。这意味着较大的模型遗忘较少**。从隐私的角度来看，这并不理想，因为这意味着较大的模型可能会保留来自训练数据的更多敏感信息。本文还研究了遗忘基线对数据批次顺序的敏感性，从不同的训练检查点开始执行上述相同的遗忘曲线分析（从第 14、39 和 63 个时期开始）来改变提供给模型的数据批次的顺序而无需大幅改变实验设置。实验结果说明遗忘基线对数据批次顺序不敏感。

也就是说如果不复习，持续训练，原来的数据的遗忘程度会逐渐逼近一个下限（遗忘基线），然后模型就停止遗忘了。

本文研究了重复和间隔重复对遗忘基线的影响。
+ 为了研究重复的影响，本文首先将特殊批次多次注入训练集，然后继续仅在训练集上进行训练，发现遗忘基线随着重复频率的函数单调递增（但也没递增多少）。
+ 为了研究间隔重复的影响，本文定期将保留集注入训练集，对其进行一次训练，然后继续仅在训练集上进行训练，实验结果发现间隔重复对遗忘基线的影响最小，与重复之间的间隔长度无关。

> 未来工作的一个方向是了解基线的结构——例如，了解基线中记忆了哪些类型的标记（词性、同义词、事实、语法）以及基线中记忆的标记与训练集中的标记的重叠。

