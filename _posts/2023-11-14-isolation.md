---
title: Isolation
description: 02-隔离机制
tags: class-note system-security
category: system-security
date: 2023-11-14
---

## 隔离思路

将系统划分为隔离的隔层，每个隔层以最小特权运行，将隔层的接口作为可信边界。

### 隔离机制

#### 基于硬件的隔离

隔离目标

+ 资源隔离：进程应当只能访问特定资源
  + UNIX许可模型
    + 根据UID来赋予权限许可，进程可以访问文件，网络包等资源，root进程（UID 0）可以访问所有资源
    + 所有资源都视为文件，每个文件一个访问控制列表（ACL），根据用户的UID和角色（所有者，群组等）赋予权限
  + 进程UID
    + 真实用户ID（RUID）：用于决定启动进程的用户，与父进程的用户ID相同
    + 有效用户ID（EUID）：用于决定进程的许可权限，可以与RUID不同
    + setuid（SUID）：一个程序在其许可中可以有一个setuid的位集合，标记程序的权限，影响子进程创建（fork）和进程执行（exec）
      + setuid：将进程的EUID设置为文件拥有者的ID，让进程以文件拥有者的权限执行文件
      + setgid：将进程的EGroup ID设定为文件的GID，让进程以文件所输组权限执行文件
      + sticky bit（严格删除标记）：开启时只有文件所有者，目录所有者和跟用户可以重命名或者删除文件，关闭时只要用户有目录的写权限就能操作

> 文件一共10位权限，第一位是文件类型，后面九位三位一组，从左往右分别是文件所属用户（u，user）权限，文件所属组（g，group）权限和其他普通用户（o，other）权限，rwx分别表示读（read，4），写（write，2）和执行（exec，1）  
> chmod u+s testfile # u+s就是给user加上SUID权限，减去就是u-s  
> chmod g+s testdir # g+s就是给group加上SGID权限，减去如上  
> chmod o+t testdir # o+t就是给others加上SBIT权限，减去如上

+ 存储隔离：进程应当无法访问另一个进程的存储

> 物理机器/CPU模式/虚拟内存/存储保护单元/可信执行环境...

  + 隔离方式：
    + 每个进程有自己的虚拟地址空间，由操作系统管理。进程使用的存储地址是虚拟地址（VAs），而不是物理地址（PAs）。每次存储访问都由CPU的存储管理单元（MMU）对地址进行转换。MMU使用多级页表进行地址转换，多级页表是页映射的稀疏树结构，使用虚拟地址作为树上的路径，叶节点是物理地址，树的根节点存储在寄存器中从而允许MMU在树上进行游走。
    + 进程间隔离：OS为每个进程创建专用的多级页表，切换进程时OS切换寄存器中树的根来支持不同进程的地址转换
    + 转译后备缓冲器（TLB，页表缓存）：多级页表访问加速机制，缓存最近转译的地址，进程首先检查页表缓存，没有再去访问页表
      + TLB保存虚拟页对应的物理页，如果映射允许访问则提供访问控制
      + 在切换时刷新TLB，硬件有进程上下文标识符（PCID）时可以不切换，PCID会划分TLB中的实体

#### 基于软件的隔离

> 语言虚拟机/基于软件的错误隔离/二进制插桩（binary instrumentation）/类型系统...

在没有硬件加强机制，或者进程抽象成本过高时，需要使用基于软件的隔离

隔离软件组件的方法

+ 存储隔离：影响所有的加载和存储
+ 控制流整合：确保所有控制流都在使用加载和存储的控制流图中
+ 完全仲裁（complete mediation）：取消所有特权指令
+ 组件边界处设立缓冲区：
  + 比如隔离的代码间使用的类似系统调用的接口，需要保证调用是正确的